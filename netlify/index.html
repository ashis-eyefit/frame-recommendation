<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Face Capture</title>
  <style>
    
    .container {
      background-color:#d6ecf0; 
      padding: 15px;
      border-radius: 12px
    }
    .branding-header {
      display: flex;
      flex-direction: column;         
      align-items: center;            
      justify-content: center;
      margin: 30px auto;
      text-align: center;
    }

    .branding-logo {
      height: 120px;                   
      width: auto;
      margin-bottom: 10px;
    }

    .branding-title {
      font-size: 40px;                
      color: #0e0e0e;
      font-weight: 700;
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
    }
    body {
      margin: 0;
      font-family: sans-serif;
      background: #d0ced0ab;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h2 {
      margin-top: 20px;
    }

    #camera-wrapper {
      position: relative;
      width: 100%;
      max-width: 400px;
      aspect-ratio: 3 / 4;
      margin-top: 20px;
      border-radius: 16px;
      overflow: hidden;
    }

    video, #preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 16px;
    }

    #canvas {
      display: none;
    }

    #overlay-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #controls {
      margin-top: 10px;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
      border-radius: 8px;
      border: none;
      background-color: blue;
      color: rgb(255, 255, 255);
      cursor: pointer;
    }

    #feedback {
      margin-top: 10px;
      font-weight: bold;
      color: black; 
      text-align: center;
      align-items: center;
    }
    
    #previewContainer {
      position: relative;
      width: 100%;
      max-width: 400px;
      aspect-ratio: 3 / 4;
      display: none;
    }
    #preview {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 16px;
    }

    </style>
  </head>
<body>
<div class="container">
  <div class="branding-header">
    <img src="assets/branding_logo.png" alt="Brand Logo" class="branding-logo">
    <h2>Frames Studio</h1>
    <h2>Experience The Intelligence</h2>
    <h3 style="color: #383737;">Align face inside the oval and capture a photo</h3>
  
    <div id="camera-wrapper">
      <video id="camera" autoplay playsinline></video>
      
      <!-- Container for preview + frame overlay -->
      <div id="previewContainer" style="position: relative; display: none; width: 100%; max-width: 400px;">
      
        <img id="preview" style="display: block; width: 100%; height: 85%; object-fit: cover;" />

        <canvas id="frameCanvas" style="position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none;"></canvas>
        <canvas id="meshCanvas" style="position: absolute; top: 0; left: 0; z-index: 15; pointer-events: none;"></canvas>

      </div>


      <!-- SVG Overlay with Wider Oval Cutout -->
      <svg id="overlay-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
        <defs>
          <mask id="mask">
            <rect width="100" height="100" fill="white"/>
            <ellipse cx="50" cy="45" rx="33" ry="35" fill="black"/>
          </mask>
        </defs>
        <rect width="100" height="100" fill="black" mask="url(#mask)" fill-opacity="0.85"/>
      </svg>

      <canvas id="canvas"></canvas>
    </div>

    <div id="controls">
      <button id="captureBtn" onclick="capture()">Capture</button>
      <button id="retakeBtn" onclick="retake()" style="display:none;">Retake</button>
      <button id="submitBtn" onclick="submit()" style="display:none;">Submit</button>
    </div>
  </div>
  <div id="feedback"></div>
  <div id="result" style="text-align: center;"></div>
</div>

<script>
let landmarks = null;

const video = document.getElementById('camera');
const canvas = document.getElementById('canvas');
const preview = document.getElementById('preview');
const feedback = document.getElementById('feedback');
const resultDiv = document.getElementById('result');

const captureBtn = document.getElementById('captureBtn');
const retakeBtn = document.getElementById('retakeBtn');
const submitBtn = document.getElementById('submitBtn');

let resultData = null;

navigator.mediaDevices.getUserMedia({ video: true })
  .then(stream => video.srcObject = stream)
  .catch(err => alert("Camera access denied."));

function capture() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const dataURL = canvas.toDataURL("image/jpeg");

  preview.src = dataURL;
  preview.style.display = "block";
  document.getElementById("previewContainer").style.display = "block";

  video.style.display = "none";
  captureBtn.style.display = "none";
  retakeBtn.style.display = "inline-block";
  
preview.dataset.originalWidth = video.videoWidth;
preview.dataset.originalHeight = video.videoHeight;

  fetch("https://frame-recommendation.onrender.com/analyze_face", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ image_base64: dataURL })
  })
  .then(res => res.json())
  .then(data => {
    if (!data || !data.landmarks) {
      feedback.innerText = "⚠️ Could not analyze face. Please try again.";
      return;
    }

    resultData = data;
    landmarks = data.landmarks;



    const { chin, forehead, jaw_l, jaw_r } = landmarks;
    const { jawline_angle, pitch_angle, roll_angle } = data;

    const ovalCenterX = canvas.width * 0.5;
    const ovalCenterY = canvas.height * 0.45;
    const ovalRadiusX = canvas.width * 0.33;
    const ovalRadiusY = canvas.height * 0.35;

    const isInsideOval = (x, y) => {
      const normX = (x - ovalCenterX) / ovalRadiusX;
      const normY = (y - ovalCenterY) / ovalRadiusY;
      return (normX * normX + normY * normY) <= 1.0;
    };

    const insideOval = [chin, forehead, jaw_l, jaw_r].every(p => isInsideOval(p.x, p.y));
    const jawOk = Math.abs(jawline_angle) <= 12;
    const pitchOk = pitch_angle >= 85 && pitch_angle <= 100;
    const rollOk = Math.abs(roll_angle) <= 10;

    const issues = [];
    if (!insideOval) issues.push("Face is not fully inside the oval.");
    if (!pitchOk) issues.push(pitch_angle < 85 ? "Head tilted down. Raise your head slightly." : "Head tilted up. Lower your chin.");
    if (!jawOk) issues.push(jawline_angle < -12 ? "Head turned right. Look straight." : "Head turned left. Look straight.");
    if (!rollOk) issues.push(roll_angle < -10 ? "Head leaning right. Straighten your head." : "Head leaning left. Straighten your head.");

    if (issues.length === 0) {
      feedback.innerText = "✅ Face aligned properly";
      drawFaceMesh(landmarks)

     
      setTimeout(() => {
      feedback.style.marginBottom = "12px";
      resultDiv.innerText = `Detected: ${data.face_shape} face, ${data.skin_tone} skin`;
      resultDiv.innerText = `Kindly, click on submit to get recommendation`
      },4000);
      submitBtn.style.display = "inline-block";
    
    } 
    else {
      feedback.innerText = "❌ " + issues.join(" ");
      resultDiv.innerText = "";
      submitBtn.style.display = "none";
    }
  })
  .catch(() => {
    feedback.innerText = "⚠️ Could not analyze face. Please try again.";
    resultDiv.innerText = "";
    submitBtn.style.display = "none";
  });
}

function retake() {
  video.style.display = "block";
  preview.style.display = "none";
  document.getElementById("meshCanvas").style.display = "none";
  feedback.innerText = "";
  resultDiv.innerText = "";
  submitBtn.style.display = "none";
  retakeBtn.style.display = "none";
  captureBtn.style.display = "inline-block";
}

function submit() {
  submitBtn.disabled = true;
  feedback.innerText = "⏳ Analyzing face for your frame recommendation...";
  resultDiv.innerText = "";

  fetch("https://frame-recommendation.onrender.com/recommend_frame", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(resultData)
  })
  .then(res => res.json())
  .then(response => {
    submitBtn.disabled = false;
    if (!response.success || !response.recommendation) {
      feedback.innerText = "❌ Recommendation not available. Please recapture.";
      return;
    }

    const { recommended_frame, recommended_color, ["reasoning summary"]: summary } = response.recommendation;
    const frameName = recommended_frame.toLowerCase();
    const colorListHtml = recommended_color.join(", ");
    const frameImagesHtml = recommended_color.map(color => `
      <div style="text-align: center; margin-bottom: 15px;">
        <canvas class="frame-tint-canvas" style="display: block; margin: auto; width: 300px;"></canvas>
        <p style="margin-top: 5px;"><strong>${color}</strong></p>
      </div>
    `).join("");

    setTimeout(() => {
      feedback.innerText = "Your personalized recommendation is ready!";
      resultDiv.innerHTML = `
        <div style="margin-top: 20px; padding: 15px; background: #8ec9f1; border-radius: 12px; box-shadow: 0 0 10px rgba(0,0,0,0.1); max-width: 400px; text-align: left;">
          <h3 style="margin-top: 0;">Personalized Recommendation</h3>
          <p><strong>Face Shape:</strong> ${resultData.face_shape}</p>
          <p><strong>Frame Shape:</strong> ${recommended_frame}</p>
          <p><strong>Frame Colors:</strong> ${colorListHtml}</p>
          ${frameImagesHtml}
          <p><strong>Recommendation Summary:</strong></p>
          <ul style="font-size: 14px; color: #333;">
            ${summary.map(point => `<li>${point.replace(/^[-•\d.]+/, "").trim()}</li>`).join("")}
          </ul>
        </div>`;
      applyColorToPreviewFrames(`/frames/${frameName}.png`, recommended_color);
    }, 2500);
  })
  .catch(() => {
    submitBtn.disabled = false;
    feedback.innerText = "❌ Network error: Could not reach recommendation server.";
  });
}

function drawFaceMesh(landmarks) {
  const canvas = document.getElementById("meshCanvas");
  const ctx = canvas.getContext("2d");

  // Ensure canvas size matches the preview (still image)
  canvas.width = preview.offsetWidth;
  canvas.height = preview.offsetHeight;
  canvas.style.display = "block";

  if (!landmarks || Object.values(landmarks).length < 4) return;

  const originalW = parseInt(preview.dataset.originalWidth || canvas.width);
  const originalH = parseInt(preview.dataset.originalHeight || canvas.height);
  const scaleX = canvas.width / originalW;
  const scaleY = canvas.height / originalH;

  const points = Object.values(landmarks).map(p => ({
    x: p.x * scaleX,
    y: p.y * scaleY
  }));

  const sparkles = points.map(p => ({
    x: p.x,
    y: p.y,
    phase: Math.random() * 2 * Math.PI
  }));

  let t = 0;
  const scanLine = { y: 0 };

  const animation = setInterval(() => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Scanline effect
    scanLine.y += 2;
    if (scanLine.y > canvas.height) scanLine.y = 0;
    const gradient = ctx.createLinearGradient(0, scanLine.y, 0, scanLine.y + 30);
    gradient.addColorStop(0, "rgba(0, 255, 255, 0)");
    gradient.addColorStop(0.5, "rgba(0, 255, 255, 0.2)");
    gradient.addColorStop(1, "rgba(0, 255, 255, 0)");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, scanLine.y, canvas.width, 30);

    // Draw mesh lines (connecting close points)
    ctx.strokeStyle = "rgba(0, 200, 255, 0.3)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < points.length - 1; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const dx = points[i].x - points[j].x;
        const dy = points[i].y - points[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 50) {
          ctx.moveTo(points[i].x, points[i].y);
          ctx.lineTo(points[j].x, points[j].y);
        }
      }
    }
    ctx.stroke();

    // Draw sparkling stars
    sparkles.forEach((s, i) => {
      const r = 1.5 + Math.sin(t + s.phase) * 1.2;
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, 2 * Math.PI);
      ctx.fillStyle = i % 2 === 0 ? "#00f2ff" : "#9b00ff";
      ctx.shadowColor = ctx.fillStyle;
      ctx.shadowBlur = 6;
      ctx.fill();
    });

    t += 0.2;
  }, 40);

  setTimeout(() => {
    clearInterval(animation);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    canvas.style.display = "none";
  }, 4000);
}
function applyColorToPreviewFrames(frameSrc, colorList) {
  const canvases = document.querySelectorAll(".frame-tint-canvas");
  canvases.forEach((canvas, i) => {
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.src = `${frameSrc}?v=${Date.now()}`;

    img.onload = () => {
      const aspectRatio = img.width / img.height;
      const displayWidth = 300;
      const displayHeight = displayWidth / aspectRatio;

      canvas.width = displayWidth;
      canvas.height = displayHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      ctx.globalCompositeOperation = 'source-in';
      const colorMap = {
        "Black": "#000000",
        "Gold": "#d4af37",
        "Tortoise Shell": "#8B4513",
        "Gunmetal Grey": "#555",
        "Transparent": "rgba(255,255,255,0.2)",
        "Rose Gold": "#b76e79",
        "Matte Blue": "#3050a0",
        "Brown": "#5c4033"
      };
      const tint = colorMap[colorList[i]] || "#000";
      ctx.fillStyle = tint;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
    };
  });
}
</script>
</body>
</html>
